use std::collections::BTreeMap;
use dpp::data_contract::{DataContract, DataContractV0, DocumentName};
use dpp::data_contract::document_type::DocumentType;
use dpp::data_contract::document_type::v0::DocumentTypeV0;
use platform_value::{Identifier, IdentifierBytes32, Value, ValueMap};

fn data_contract_() {
//     let data_contract = DataContract::V0(
//         DataContractV0 {
//             id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])),
//             version: 1,
//             owner_id: Identifier(IdentifierBytes32([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
//             document_types: {
//                 "domain": V0(DocumentTypeV0 { name: "domain", schema: Map([(Text("documentsMutable"), Bool(false)), (Text("canBeDeleted"), Bool(true)), (Text("transferable"), U64(1)), (Text("tradeMode"), U64(1)), (Text("type"), Text("object")), (Text("indices"), Array([Map([(Text("name"), Text("parentNameAndLabel")), (Text("properties"), Array([Map([(Text("normalizedParentDomainName"), Text("asc"))]), Map([(Text("normalizedLabel"), Text("asc"))])])), (Text("unique"), Bool(true)), (Text("contested"), Map([(Text("fieldMatches"), Array([Map([(Text("field"), Text("normalizedLabel")), (Text("regexPattern"), Text("^[a-zA-Z01-]{3,19}$"))])])), (Text("resolution"), U64(0)), (Text("description"), Text("If the normalized label part of this index is less than 20 characters (all alphabet a-z, A-Z, 0, 1, and -) then a masternode vote contest takes place to give out the name"))]))]), Map([(Text("name"), Text("identityId")), (Text("nullSearchable"), Bool(false)), (Text("properties"), Array([Map([(Text("records.identity"), Text("asc"))])]))])])), (Text("properties"), Map([(Text("label"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(3)), (Text("maxLength"), U64(63)), (Text("position"), U64(0)), (Text("description"), Text("Domain label. e.g. 'Bob'."))])), (Text("normalizedLabel"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-]{0,61}[a-hj-km-np-z0-9]$")), (Text("maxLength"), U64(63)), (Text("position"), U64(1)), (Text("description"), Text("Domain label converted to lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'b0b'")), (Text("$comment"), Text("Must be equal to the label in lowercase. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\"."))])), (Text("parentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(2)), (Text("description"), Text("A full parent domain name. e.g. 'dash'."))])), (Text("normalizedParentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-\\.]{0,61}[a-hj-km-np-z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(3)), (Text("description"), Text("A parent domain name in lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'dash'")), (Text("$comment"), Text("Must either be equal to an existing domain or empty to create a top level domain. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\". Only the data contract owner can create top level domains."))])), (Text("preorderSalt"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(4)), (Text("description"), Text("Salt used in the preorder document"))])), (Text("records"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("identity"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(1)), (Text("contentMediaType"), Text("application/x.dash.dpp.identifier")), (Text("description"), Text("Identifier name record that refers to an Identity"))]))])), (Text("minProperties"), U64(1)), (Text("position"), U64(5)), (Text("additionalProperties"), Bool(false))])), (Text("subdomainRules"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("allowSubdomains"), Map([(Text("type"), Text("boolean")), (Text("description"), Text("This option defines who can create subdomains: true - anyone; false - only the domain owner")), (Text("$comment"), Text("Only the domain owner is allowed to create subdomains for non top-level domains")), (Text("position"), U64(0))]))])), (Text("position"), U64(6)), (Text("description"), Text("Subdomain rules allow domain owners to define rules for subdomains")), (Text("additionalProperties"), Bool(false)), (Text("required"), Array([Text("allowSubdomains")]))]))])), (Text("required"), Array([Text("$createdAt"), Text("$updatedAt"), Text("$transferredAt"), Text("label"), Text("normalizedLabel"), Text("normalizedParentDomainName"), Text("preorderSalt"), Text("records"), Text("subdomainRules")])), (Text("transient"), Array([Text("preorderSalt")])), (Text("additionalProperties"), Bool(false)), (Text("$comment"), Text("In order to register a domain you need to create a preorder. The preorder step is needed to prevent man-in-the-middle attacks. normalizedLabel + '.' + normalizedParentDomain must not be longer than 253 chars length as defined by RFC 1035. Domain documents are immutable: modification and deletion are restricted"))]), indices: {"identityId": Index { name: "identityId", properties: [IndexProperty { name: "records.identity", ascending: true }], unique: false, null_searchable: false, contested_index: None }, "parentNameAndLabel": Index { name: "parentNameAndLabel", properties: [IndexProperty { name: "normalizedParentDomainName", ascending: true }, IndexProperty { name: "normalizedLabel", ascending: true }], unique: true, null_searchable: true, contested_index: Some(ContestedIndexInformation { field_matches: {"normalizedLabel": Regex(Regex("^[a-zA-Z01-]{3,19}$"))}, resolution: MasternodeVote }) }}, index_structure: IndexLevel { sub_index_levels: {"normalizedParentDomainName": IndexLevel { sub_index_levels: {"normalizedLabel": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: true, index_type: UniqueIndex }), level_identifier: 3 }}, has_index_with_type: None, level_identifier: 2 }, "records.identity": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: false, index_type: NonUniqueIndex }), level_identifier: 1 }}, has_index_with_type: None, level_identifier: 0 }, flattened_properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records.identity": DocumentProperty { property_type: Identifier, required: false, transient: false }, "subdomainRules.allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}, properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records": DocumentProperty { property_type: Object({"identity": DocumentProperty { property_type: Identifier, required: false, transient: false }}), required: true, transient: false }, "subdomainRules": DocumentProperty { property_type: Object({"allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}), required: true, transient: false }}, identifier_paths: {"records.identity"}, binary_paths: {"preorderSalt"}, required_fields: {"$createdAt", "$transferredAt", "$updatedAt", "label", "normalizedLabel", "normalizedParentDomainName", "preorderSalt", "records", "subdomainRules", "subdomainRules.allowSubdomains"}, transient_fields: {"preorderSalt"}, documents_keep_history: false, documents_mutable: false, documents_can_be_deleted: true, documents_transferable: Always, trade_mode: DirectPurchase, creation_restriction_mode: NoRestrictions, data_contract_id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])), requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None, security_level_requirement: HIGH, json_schema_validator: StatelessJsonSchemaLazyValidator(JsonSchemaValidator { validator: RwLock { data: None, poisoned: false, .. } }) }),
//                 "preorder": V0(DocumentTypeV0 { name: "preorder", schema: Map([(Text("documentsMutable"), Bool(false)), (Text("canBeDeleted"), Bool(true)), (Text("type"), Text("object")), (Text("indices"), Array([Map([(Text("name"), Text("saltedHash")), (Text("properties"), Array([Map([(Text("saltedDomainHash"), Text("asc"))])])), (Text("unique"), Bool(true))])])), (Text("properties"), Map([(Text("saltedDomainHash"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(0)), (Text("description"), Text("Double sha-256 of the concatenation of a 32 byte random salt and a normalized domain name"))]))])), (Text("required"), Array([Text("saltedDomainHash")])), (Text("additionalProperties"), Bool(false)), (Text("$comment"), Text("Preorder documents are immutable: modification and deletion are restricted"))]), indices: {"saltedHash": Index { name: "saltedHash", properties: [IndexProperty { name: "saltedDomainHash", ascending: true }], unique: true, null_searchable: true, contested_index: None }}, index_structure: IndexLevel { sub_index_levels: {"saltedDomainHash": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: true, index_type: UniqueIndex }), level_identifier: 1 }}, has_index_with_type: None, level_identifier: 0 }, flattened_properties: {"saltedDomainHash": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: false }}, properties: {"saltedDomainHash": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: false }}, identifier_paths: {}, binary_paths: {"saltedDomainHash"}, required_fields: {"saltedDomainHash"}, transient_fields: {}, documents_keep_history: false, documents_mutable: false, documents_can_be_deleted: true, documents_transferable: Never, trade_mode: None, creation_restriction_mode: NoRestrictions, data_contract_id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])), requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None, security_level_requirement: HIGH, json_schema_validator: StatelessJsonSchemaLazyValidator(JsonSchemaValidator { validator: RwLock { data: None, poisoned: false, .. } }) })}, metadata: None, config: V0(DataContractConfigV0 { can_be_deleted: false, readonly: false, keeps_history: false, documents_keep_history_contract_default: false, documents_mutable_contract_default: true, documents_can_be_deleted_contract_default: true, requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None }), schema_defs: None })
//
// ;

    DataContract::generate_data_contract_id_v0(dpns_contract::ID_BYTES, 0);

    let mut schema_tree: BTreeMap<DocumentName, Value> = BTreeMap::new();
    schema_tree.insert("domain".into(), Value::Map(vec![(Text("documentsMutable"), Bool(false)), (Text("canBeDeleted"), Bool(true)), (Text("transferable"), U64(1)), (Text("tradeMode"), U64(1)), (Text("type"), Text("object")), (Text("indices"), Array([Map([(Text("name"), Text("parentNameAndLabel")), (Text("properties"), Array([Map([(Text("normalizedParentDomainName"), Text("asc"))]), Map([(Text("normalizedLabel"), Text("asc"))])])), (Text("unique"), Bool(true)), (Text("contested"), Map([(Text("fieldMatches"), Array([Map([(Text("field"), Text("normalizedLabel")), (Text("regexPattern"), Text("^[a-zA-Z01-]{3,19}$"))])])), (Text("resolution"), U64(0)), (Text("description"), Text("If the normalized label part of this index is less than 20 characters (all alphabet a-z, A-Z, 0, 1, and -) then a masternode vote contest takes place to give out the name"))]))]), Map([(Text("name"), Text("identityId")), (Text("nullSearchable"), Bool(false)), (Text("properties"), Array([Map([(Text("records.identity"), Text("asc"))])]))])])), (Text("properties"), Map([(Text("label"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(3)), (Text("maxLength"), U64(63)), (Text("position"), U64(0)), (Text("description"), Text("Domain label. e.g. 'Bob'."))])), (Text("normalizedLabel"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-]{0,61}[a-hj-km-np-z0-9]$")), (Text("maxLength"), U64(63)), (Text("position"), U64(1)), (Text("description"), Text("Domain label converted to lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'b0b'")), (Text("$comment"), Text("Must be equal to the label in lowercase. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\"."))])), (Text("parentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(2)), (Text("description"), Text("A full parent domain name. e.g. 'dash'."))])), (Text("normalizedParentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-\\.]{0,61}[a-hj-km-np-z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(3)), (Text("description"), Text("A parent domain name in lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'dash'")), (Text("$comment"), Text("Must either be equal to an existing domain or empty to create a top level domain. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\". Only the data contract owner can create top level domains."))])), (Text("preorderSalt"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(4)), (Text("description"), Text("Salt used in the preorder document"))])), (Text("records"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("identity"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(1)), (Text("contentMediaType"), Text("application/x.dash.dpp.identifier")), (Text("description"), Text("Identifier name record that refers to an Identity"))]))])), (Text("minProperties"), U64(1)), (Text("position"), U64(5)), (Text("additionalProperties"), Bool(false))])), (Text("subdomainRules"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("allowSubdomains"), Map([(Text("type"), Text("boolean")), (Text("description"), Text("This option defines who can create subdomains: true - anyone; false - only the domain owner")), (Text("$comment"), Text("Only the domain owner is allowed to create subdomains for non top-level domains")), (Text("position"), U64(0))]))])), (Text("position"), U64(6)), (Text("description"), Text("Subdomain rules allow domain owners to define rules for subdomains")), (Text("additionalProperties"), Bool(false)), (Text("required"), Array([Text("allowSubdomains")]))]))])), (Text("required"), Array([Text("$createdAt"), Text("$updatedAt"), Text("$transferredAt"), Text("label"), Text("normalizedLabel"), Text("normalizedParentDomainName"), Text("preorderSalt"), Text("records"), Text("subdomainRules")])), (Text("transient"), Array([Text("preorderSalt")])), (Text("additionalProperties"), Bool(false)), (Text("$comment"), Text("In order to register a domain you need to create a preorder. The preorder step is needed to prevent man-in-the-middle attacks. normalizedLabel + '.' + normalizedParentDomain must not be longer than 253 chars length as defined by RFC 1035. Domain documents are immutable: modification and deletion are restricted"))]), indices: {"identityId": Index { name: "identityId", properties: [IndexProperty { name: "records.identity", ascending: true }], unique: false, null_searchable: false, contested_index: None }, "parentNameAndLabel": Index { name: "parentNameAndLabel", properties: [IndexProperty { name: "normalizedParentDomainName", ascending: true }, IndexProperty { name: "normalizedLabel", ascending: true }], unique: true, null_searchable: true, contested_index: Some(ContestedIndexInformation { field_matches: {"normalizedLabel": Regex(Regex("^[a-zA-Z01-]{3,19}$"))}, resolution: MasternodeVote }) }}, index_structure: IndexLevel { sub_index_levels: {"normalizedParentDomainName": IndexLevel { sub_index_levels: {"normalizedLabel": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: true, index_type: UniqueIndex }), level_identifier: 3 }}, has_index_with_type: None, level_identifier: 2 }, "records.identity": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: false, index_type: NonUniqueIndex }), level_identifier: 1 }}, has_index_with_type: None, level_identifier: 0 }, flattened_properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records.identity": DocumentProperty { property_type: Identifier, required: false, transient: false }, "subdomainRules.allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}, properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records": DocumentProperty { property_type: Object({"identity": DocumentProperty { property_type: Identifier, required: false, transient: false }}), required: true, transient: false }, "subdomainRules": DocumentProperty { property_type: Object({"allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}), required: true, transient: false }}, identifier_paths: {"records.identity"}, binary_paths: {"preorderSalt"}, required_fields: {"$createdAt", "$transferredAt", "$updatedAt", "label", "normalizedLabel", "normalizedParentDomainName", "preorderSalt", "records", "subdomainRules", "subdomainRules.allowSubdomains"}, transient_fields: {"preorderSalt"}, documents_keep_history: false, documents_mutable: false, documents_can_be_deleted: true, documents_transferable: Always, trade_mode: DirectPurchase, creation_restriction_mode: NoRestrictions, data_contract_id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])), requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None, security_level_requirement: HIGH, json_schema_validator: StatelessJsonSchemaLazyValidator(JsonSchemaValidator { validator: RwLock { data: None, poisoned: false, .. } }) })],
    //schema_tree.insert("preorder".into(): V0(DocumentTypeV0 { name: "preorder", schema: Map([(Text("documentsMutable"), Bool(false)), (Text("canBeDeleted"), Bool(true)), (Text("type"), Text("object")), (Text("indices"), Array([Map([(Text("name"), Text("saltedHash")), (Text("properties"), Array([Map([(Text("saltedDomainHash"), Text("asc"))])])), (Text("unique"), Bool(true))])])), (Text("properties"), Map([(Text("saltedDomainHash"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(0)), (Text("description"), Text("Double sha-256 of the concatenation of a 32 byte random salt and a normalized domain name"))]))])), (Text("required"), Array([Text("saltedDomainHash")])), (Text("additionalProperties"), Bool(false)), (Text("$comment"), Text("Preorder documents are immutable: modification and deletion are restricted"))]), indices: {"saltedHash": Index { name: "saltedHash", properties: [IndexProperty { name: "saltedDomainHash", ascending: true }], unique: true, null_searchable: true, contested_index: None }}, index_structure: IndexLevel { sub_index_levels: {"saltedDomainHash": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: true, index_type: UniqueIndex }), level_identifier: 1 }}, has_index_with_type: None, level_identifier: 0 }, flattened_properties: {"saltedDomainHash": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: false }}, properties: {"saltedDomainHash": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: false }}, identifier_paths: {}, binary_paths: {"saltedDomainHash"}, required_fields: {"saltedDomainHash"}, transient_fields: {}, documents_keep_history: false, documents_mutable: false, documents_can_be_deleted: true, documents_transferable: Never, trade_mode: None, creation_restriction_mode: NoRestrictions, data_contract_id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])), requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None, security_level_requirement: HIGH, json_schema_validator: StatelessJsonSchemaLazyValidator(JsonSchemaValidator { validator: RwLock { data: None, poisoned: false, .. } }) })}, metadata: None, config: V0(DataContractConfigV0 { can_be_deleted: false, readonly: false, keeps_history: false, documents_keep_history_contract_default: false, documents_mutable_contract_default: true, documents_can_be_deleted_contract_default: true, requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None }), schema_defs: None })

    // let document_type = DocumentType::create_document_types_from_document_schemas(
    //     Identifier.from(dpns_contract::ID_BYTES),
    //     sc
    // );
    // let document_type = DocumentType::V0(DocumentTypeV0 { name: "domain", schema: Map([(Text("documentsMutable"), Bool(false)), (Text("canBeDeleted"), Bool(true)), (Text("transferable"), U64(1)), (Text("tradeMode"), U64(1)), (Text("type"), Text("object")), (Text("indices"), Array([Map([(Text("name"), Text("parentNameAndLabel")), (Text("properties"), Array([Map([(Text("normalizedParentDomainName"), Text("asc"))]), Map([(Text("normalizedLabel"), Text("asc"))])])), (Text("unique"), Bool(true)), (Text("contested"), Map([(Text("fieldMatches"), Array([Map([(Text("field"), Text("normalizedLabel")), (Text("regexPattern"), Text("^[a-zA-Z01-]{3,19}$"))])])), (Text("resolution"), U64(0)), (Text("description"), Text("If the normalized label part of this index is less than 20 characters (all alphabet a-z, A-Z, 0, 1, and -) then a masternode vote contest takes place to give out the name"))]))]), Map([(Text("name"), Text("identityId")), (Text("nullSearchable"), Bool(false)), (Text("properties"), Array([Map([(Text("records.identity"), Text("asc"))])]))])])), (Text("properties"), Map([(Text("label"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(3)), (Text("maxLength"), U64(63)), (Text("position"), U64(0)), (Text("description"), Text("Domain label. e.g. 'Bob'."))])), (Text("normalizedLabel"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-]{0,61}[a-hj-km-np-z0-9]$")), (Text("maxLength"), U64(63)), (Text("position"), U64(1)), (Text("description"), Text("Domain label converted to lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'b0b'")), (Text("$comment"), Text("Must be equal to the label in lowercase. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\"."))])), (Text("parentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(2)), (Text("description"), Text("A full parent domain name. e.g. 'dash'."))])), (Text("normalizedParentDomainName"), Map([(Text("type"), Text("string")), (Text("pattern"), Text("^$|^[a-hj-km-np-z0-9][a-hj-km-np-z0-9-\\.]{0,61}[a-hj-km-np-z0-9]$")), (Text("minLength"), U64(0)), (Text("maxLength"), U64(63)), (Text("position"), U64(3)), (Text("description"), Text("A parent domain name in lowercase for case-insensitive uniqueness validation. \"o\", \"i\" and \"l\" replaced with \"0\" and \"1\" to mitigate homograph attack. e.g. 'dash'")), (Text("$comment"), Text("Must either be equal to an existing domain or empty to create a top level domain. \"o\", \"i\" and \"l\" must be replaced with \"0\" and \"1\". Only the data contract owner can create top level domains."))])), (Text("preorderSalt"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(4)), (Text("description"), Text("Salt used in the preorder document"))])), (Text("records"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("identity"), Map([(Text("type"), Text("array")), (Text("byteArray"), Bool(true)), (Text("minItems"), U64(32)), (Text("maxItems"), U64(32)), (Text("position"), U64(1)), (Text("contentMediaType"), Text("application/x.dash.dpp.identifier")), (Text("description"), Text("Identifier name record that refers to an Identity"))]))])), (Text("minProperties"), U64(1)), (Text("position"), U64(5)), (Text("additionalProperties"), Bool(false))])), (Text("subdomainRules"), Map([(Text("type"), Text("object")), (Text("properties"), Map([(Text("allowSubdomains"), Map([(Text("type"), Text("boolean")), (Text("description"), Text("This option defines who can create subdomains: true - anyone; false - only the domain owner")), (Text("$comment"), Text("Only the domain owner is allowed to create subdomains for non top-level domains")), (Text("position"), U64(0))]))])), (Text("position"), U64(6)), (Text("description"), Text("Subdomain rules allow domain owners to define rules for subdomains")), (Text("additionalProperties"), Bool(false)), (Text("required"), Array([Text("allowSubdomains")]))]))])), (Text("required"), Array([Text("$createdAt"), Text("$updatedAt"), Text("$transferredAt"), Text("label"), Text("normalizedLabel"), Text("normalizedParentDomainName"), Text("preorderSalt"), Text("records"), Text("subdomainRules")])), (Text("transient"), Array([Text("preorderSalt")])), (Text("additionalProperties"), Bool(false)), (Text("$comment"), Text("In order to register a domain you need to create a preorder. The preorder step is needed to prevent man-in-the-middle attacks. normalizedLabel + '.' + normalizedParentDomain must not be longer than 253 chars length as defined by RFC 1035. Domain documents are immutable: modification and deletion are restricted"))]), indices: {"identityId": Index { name: "identityId", properties: [IndexProperty { name: "records.identity", ascending: true }], unique: false, null_searchable: false, contested_index: None }, "parentNameAndLabel": Index { name: "parentNameAndLabel", properties: [IndexProperty { name: "normalizedParentDomainName", ascending: true }, IndexProperty { name: "normalizedLabel", ascending: true }], unique: true, null_searchable: true, contested_index: Some(ContestedIndexInformation { field_matches: {"normalizedLabel": Regex(Regex("^[a-zA-Z01-]{3,19}$"))}, resolution: MasternodeVote }) }}, index_structure: IndexLevel { sub_index_levels: {"normalizedParentDomainName": IndexLevel { sub_index_levels: {"normalizedLabel": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: true, index_type: UniqueIndex }), level_identifier: 3 }}, has_index_with_type: None, level_identifier: 2 }, "records.identity": IndexLevel { sub_index_levels: {}, has_index_with_type: Some(IndexLevelTypeInfo { should_insert_with_all_null: false, index_type: NonUniqueIndex }), level_identifier: 1 }}, has_index_with_type: None, level_identifier: 0 }, flattened_properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records.identity": DocumentProperty { property_type: Identifier, required: false, transient: false }, "subdomainRules.allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}, properties: {"label": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(3), max_length: Some(63) }), required: true, transient: false }, "normalizedLabel": DocumentProperty { property_type: String(StringPropertySizes { min_length: None, max_length: Some(63) }), required: true, transient: false }, "parentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: false, transient: false }, "normalizedParentDomainName": DocumentProperty { property_type: String(StringPropertySizes { min_length: Some(0), max_length: Some(63) }), required: true, transient: false }, "preorderSalt": DocumentProperty { property_type: ByteArray(ByteArrayPropertySizes { min_size: Some(32), max_size: Some(32) }), required: true, transient: true }, "records": DocumentProperty { property_type: Object({"identity": DocumentProperty { property_type: Identifier, required: false, transient: false }}), required: true, transient: false }, "subdomainRules": DocumentProperty { property_type: Object({"allowSubdomains": DocumentProperty { property_type: Boolean, required: true, transient: false }}), required: true, transient: false }}, identifier_paths: {"records.identity"}, binary_paths: {"preorderSalt"}, required_fields: {"$createdAt", "$transferredAt", "$updatedAt", "label", "normalizedLabel", "normalizedParentDomainName", "preorderSalt", "records", "subdomainRules", "subdomainRules.allowSubdomains"}, transient_fields: {"preorderSalt"}, documents_keep_history: false, documents_mutable: false, documents_can_be_deleted: true, documents_transferable: Always, trade_mode: DirectPurchase, creation_restriction_mode: NoRestrictions, data_contract_id: Identifier(IdentifierBytes32([230, 104, 198, 89, 175, 102, 174, 225, 231, 44, 24, 109, 222, 123, 91, 126, 10, 29, 113, 42, 9, 196, 13, 87, 33, 246, 34, 191, 83, 197, 49, 85])), requires_identity_encryption_bounded_key: None, requires_identity_decryption_bounded_key: None, security_level_requirement: HIGH, json_schema_validator: StatelessJsonSchemaLazyValidator(JsonSchemaValidator { validator: RwLock { data: None, poisoned: false, .. } }) }),
    //